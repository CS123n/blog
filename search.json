[{"title":"Docker配置","url":"/2021/08/docker/","content":"Openwrt中有使用docker的需求，顺道学习一下docker的配置。\n空间挂载openwrt默认是/opt和/overlay共用空间，因为文件格式等问题，docker在这种情况下只能使用vfs储存模式，占用空间大且速度慢。为此，在openwrt中分别为overlay和docker的opt分别分配空间并格式化为ext4格式，然后把/overlay和/opt分别挂载在上面，这样docker就会自动使用更好更快的overlay2储存模式。\n\n另外，我还将一块移动硬盘挂载在/mnt/share，而且将它通过Samba进行网络共享，共享下局域网传文件速度还是很可观的。\n\nHomeassistant首先是使用docker在openwrt中安装Homeassistant，这样就可以本地搭建智能家居服务器。Homeassistant使用MQTT协议的通信服务，所以还搭建了一个基于MQTT的开源服务器Eclipse Mosquitto的docker。\n\nHomeassistant\nMQTT\nEclipse Mosquitto\n\nMQTT首先设置配置文件\nmkdir -p /mosquitto/configmkdir -p /mosquitto/datamkdir -p /mosquitto/lognano /mosquitto/config/mosquitto.conf\n并在mosquitto.conf中添加\npersistence truepersistence_location /mosquitto/datalog_dest file /mosquitto/log/mosquitto.log\n如果需要使用密码，因为我只在局域网提供服务，就没有添加用户名密码。在mosquitto.conf中添加\nallow_anonymous falsepassword_file /mosquitto/pwfile\n然后在容器启动后运行命令，添加用户admin以及密码\nmosquitto_passwd -c /mosquitto/pwfile admin\n并授予目录权限\nchmod -R 755 /mosquittochmode -R 777 /mosquitto/log\n完成以上准备后，启动容器\ndocker run -d --name=&quot;mosquitto&quot; --net=host \\    -v /mosquitto/config/mosquitto.conf:/mosquitto/config/mosquitto.conf \\    -v /mosquitto/data:/mosquitto/data \\    -v /mosquitto/log:/mosquitto/log \\    eclipse-mosquitto:1.6.14\n要注意的是，一是最新版本的Eclipse Mosquitto 2无法被正常访问，所以建议使用1.6.14版本。二是在openwrt中的桥接模式，端口映射后被其他终端直接访问有问题，建议直接使用host模式，共享网络。\nHomeassistant接下来运行Homeassistant\ndocker run -d --name=&quot;home-assistants&quot; -p 8123:8123 \\    -v /root/homeassistant/config:/config \\    -v /mnt/share:/mnt/share \\    homeassistant/home-assistant\n除了将配置文件进行映射，我还将我的分享目录进行了映射，这样就可以通过Homeassistant直接访问分享目录下的影视资源。\nNginx+PHP为了为局域网添加Speedtest。刚开始打算直接添加Speedtest的docker，可惜出现了架构不兼容的问题\nWARNING: The requested image&#x27;s platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested\n为此，我决定曲线救国，使用docker搭建web服务器。开始打算使用集成好的docker镜像，最后还是决定使用docker-compose的方案。分别安装nginx和php的官方docker镜像，这两个镜像都没有架构兼容性问题。\n首先安装php\ndocker run -d --name=&quot;web-php&quot; -p 9000:9000 \\    -v /root/nginx/webroot:/usr/share/nginx/html \\    php:7.2-fpm\n\n其次添加nginx的配置文件conf.d\nserver &#123;    listen 80 default_server;    listen [::]:80 default_server;    server_name localhost;    index index.php index.html;    error_log  /var/log/nginx/error.log;    access_log /var/log/nginx/access.log;    root /var/www/html;    set $virtualdir &quot;&quot;;    set $realdir &quot;&quot;;    if ($request_uri ~ ^/([^/]*)/.*$ ) &#123;        set $virtualdir /$1;    &#125;    if (-d &quot;$document_root$virtualdir&quot;) &#123;        set $realdir &quot;$&#123;virtualdir&#125;&quot;;    &#125;    location / &#123;        try_files $uri $uri/ $realdir/index.php?$args;    &#125;    location ~ \\.php$ &#123;        try_files $uri =404;        fastcgi_split_path_info ^(.+\\.php)(/.+)$;        fastcgi_pass 192.168.2.110:9000;        fastcgi_index index.php;        include fastcgi_params;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        fastcgi_param PATH_INFO $fastcgi_path_info;    &#125;&#125;\n其中，文件路径为/root/nginx/webroot。并且将\nfastcgi_pass 192.168.2.110:9000;\n中的地址修改为php的运行位置。建议不要用桥接的地址，因为我发现每次重启后，桥接地址是可能发生变换的，建议端口映射后，直接使用局域网地址。\n然后运行nginx\ndocker run -d --name=&quot;web-nginx&quot; -p 8088:80 \\    -v /root/nginx/conf.d:/etc/nginx/conf.d    -v /root/nginx/webroot:/usr/share/nginx/html    nginx:latest\n有个问题是，8080端口不能正常使用，建议使用自定义端口，譬如我用的8088端口。\nSpeedtest成功运行后，在文件目录，我的是/root/nginx/webroot，添加Speedtest的网站文件。并将example-singleServer-full.html重命名为默认文件index.html。然后就可以直接访问对应的网址测速了，我的是192.168.2.110:8088/speedtest/。\n\nSpeedtest\n\n当当当当，最终的测速效果如下\n\n","categories":["极客","服务器"],"tags":["Openwrt","docker","homeassistant"]},{"title":"Homeassistant","url":"/2021/08/homeassistant/","content":"在Openwrt上搭建Homeassistant，目标是实现低成本可扩展的智能家居系统。\n安装Hacs因为Homeassistant的集成是需要审核通过的，很多开源的集成是没有加入的。所以推荐安装Hacs，它拥有更大的集成市场。官方推荐的安装方法是直接进入容器，运行命令\nwget -q -O - https://install.hacs.xyz | bash -\n但是我的docker内的网络并不能正确访问外网。通过分析代码发现，可以直接在Homeassistant的外部目录下运行脚本安装，从而不需要进入容器。其中，需要添加Homeassistant的目录到脚本的目录声明中\ndeclare -a paths=(&quot;/root/homeassistant/config&quot;)\n我的是/root/homeassistant/config。设置好后直接运行脚本。重启Homeassistant之后，就可以在集成中搜索到Hacs了。这里需要注意的是，它自带的Github api有次数限制，建议直接在configuration.yaml中添加\nhacs:    token: 自己申请的Github token\n就可以避开这一限制了。\n\nHacs\nGithub token\n\n彩云天气我使用Hacs添加了彩云天气的集成，彩云天气的api我早有申请，这次就直接用上了。彩云天气可以方便地根据经纬度坐标添加多地的天气预报，很符合我这种异地上学的人的需求。\n\n彩云天气\n\n小米云服务在Hacs的集成中，我还找到了一个有意思的小米云服务，小米手机开启手机找回功能后，就可以通过集成这个服务，来定位手机，可以说非常的方便，也免去了很多Homeassistant实现相同功能需要的权限申请。\n百度地图虽然Homeassistant自带了地图组件，但是在国内地图信息实在是令人不敢恭维。所以，有人设计了使用百度地图替代官方地图的集成，这一集成我并没有在Hacs中找到，建议直接从Github上下载安装到custom_components目录下。\n\nha_baidu_map\n\n添加MQTT通过之前已经通过docker安装了MQTT服务器，我们直接在Homeassistant集成中添加MQTT服务，并输入对应的ip地址和端口，因为是内网服务，所以我就没有设置账户密码，直接留空。\n编写Nodemcu程序有了MQTT服务以后，就可以通过MQTT添加Nodemcu等esp8266开发板，实现低成本的智能家居方案。\n温湿度计我首先在一个Nodemcu开发板上连上了一个SHTC3温湿度传感器，效果如下。然后编写了代码，烧录入Nodemcu，完整代码见附录1。\n\n红外遥控另外，通过非常好用的IRremoteESP8266这个库，我们可以方便地配置发射红外信号。\n\n通过对MQTT信号的读取和处理，实现了远程红外遥控器。具体涉及到信号的读取，将byte转化为string。\n红外信号的发射，通过IRremoteESP8266发射对应的红外信号，我家用的是格力的空调，对应可以使用ir_Kelvinator库。\n\n完整代码见附录2。\n路由器Homeassistant支持添加路由器监控，对于我使用的Openwrt的路由器，可以在路由器上安装luci-mod-rpc。然后在configuration.yaml添加\ndevice_tracker:    - platform: luci        host: 172.17.0.1        username:         password: \n重启Homeassistant就可以看到路由器上的设备了。还可以通过配置known_devices.yaml文件，为对应的设备添加设备名称等等。\nLovelaceHacs不仅仅有丰富的集成，还提供了很多好卡的ui元素，我比较喜欢一款叫clear的主题。启用Hacs中的主题需要在configuration.yaml添加\nfrontend:    themes: !include_dir_merge_named themes\n另外，还可以通过 左边栏姓名 $\\to$ 排序和隐藏侧边栏中的项目 来重新排列或隐藏左边栏的项目。\n当当当当，最终的完整效果如下\n\n附录温湿度计代码#include &lt;Arduino.h&gt;#include &quot;SparkFun_SHTC3.h&quot;#include &quot;EspMQTTClient.h&quot;#define PIN_HONG 13#define PIN_WEN 9EspMQTTClient client(  &quot;RM2100&quot;,          // wifi名  &quot;&quot;,                // wifi密码  &quot;192.168.2.110&quot;,   // MQTT Broker server ip  &quot;&quot;,                // MQTT账户名  &quot;&quot;,                // MQTT密码  &quot;mqtt01-aweoif&quot;,   // 设备自定义名  1883               // MQTT端口);SHTC3 mySHTC3;float RH,T;char temp[128] = &quot;empty&quot;;void setup() &#123;  // put your setup code here, to run once:  Serial.begin(115200);  while(Serial == false)&#123;delay(500);&#125;;    mySHTC3.begin();  pinMode(LED_BUILTIN, OUTPUT);  digitalWrite(LED_BUILTIN, HIGH);  client.enableDebuggingMessages(); // Enable debugging messages sent to serial output  client.enableHTTPWebUpdater(); // Enable the web updater. User and password default to values of MQTTUsername and MQTTPassword. These can be overrited with enableHTTPWebUpdater(&quot;user&quot;, &quot;password&quot;).  client.enableLastWillMessage(&quot;TestClient/lastwill&quot;, &quot;I am going offline&quot;);  // You can activate the retain flag by setting the third parameter to true&#125;void loop() &#123;  client.loop();//  温湿度传感器  if(millis()%20000 &lt;= 5)&#123;    SHTC3_Status_TypeDef result = mySHTC3.update();    if(mySHTC3.lastStatus == SHTC3_Status_Nominal)   //判断SHTC3状态    &#123;      RH = mySHTC3.toPercent();   //读取湿度数据                             T = mySHTC3.toDegC();       //读取温度数据         Serial.print(RH);      Serial.print(&quot;  &quot;);      Serial.println(T);            snprintf(temp,11,&quot;%.1f&quot;,T);      client.publish(&quot;esp8266/temp&quot;,temp);      snprintf(temp,11,&quot;%.1f&quot;,RH);      client.publish(&quot;esp8266/hum&quot;,temp);               &#125;else&#123;      Serial.println(&quot;Update failed!&quot;);    &#125;  &#125;  delay(5);&#125;\n\n格力遥控器代码#include &lt;Arduino.h&gt;#include &lt;IRremoteESP8266.h&gt;#include &lt;IRsend.h&gt;#include &lt;ir_Kelvinator.h&gt;#include &lt;ESP8266WiFi.h&gt;#include &lt;PubSubClient.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;const uint16_t kIrLed = 15;  // ESP8266 GPIO pin to use. Recommended: 4 (D2).IRKelvinatorAC ac(kIrLed);  // Set the GPIO to be used for sending messages.// WiFiconst char *ssid = &quot;&quot;;      // Enter your WiFi nameconst char *password = &quot;&quot;;  // Enter WiFi password// MQTT Brokerconst char *mqtt_broker = &quot;192.168.2.110&quot;;const char *mqtt_username = &quot;&quot;;const char *mqtt_password = &quot;&quot;;const char* client_id = &quot;clientId-gfdsgr&quot;;  const int mqtt_port = 1883;const char *topic0 = &quot;esp8266/setopen&quot;;const char *topic1 = &quot;esp8266/setmod&quot;;const char *topic2 = &quot;esp8266/settemp&quot;;const char *topic3 = &quot;esp8266/setfan&quot;;const char *topic4 = &quot;esp8266/setvert&quot;;const char *topic5 = &quot;esp8266/sethori&quot;;char setopen[128] = &quot;on&quot;;uint8_t setmod = kKelvinatorCool;int settemp = 26;int setfan = 1;WiFiClient espClient;PubSubClient client(espClient);void setup() &#123;  Serial.begin(115200);  ac.begin();  delay(1000);    WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;      delay(1000);      Serial.println(&quot;Connecting to WiFi..&quot;);  &#125;  Serial.println(&quot;Connected to the WiFi network&quot;);  //connecting to a mqtt broker  client.setServer(mqtt_broker, mqtt_port);  client.setCallback(callback);  // Set up what we want to send. See ir_Kelvinator.cpp for all the options.  // Most things default to off.  ac.off();  ac.setFan(setfan);  ac.setMode(kKelvinatorCool);  ac.setTemp(settemp);  ac.setSwingVertical(true);  ac.setSwingHorizontal(true);  printState();&#125;void callback(char* topic, byte* payload, unsigned int length) &#123;   Serial.print(&quot;Message arrived in topic: &quot;);  Serial.println(topic);   Serial.print(&quot;Message:&quot;);//  for (int i = 0; i &lt; length; i++) &#123;//    Serial.print((char)payload[i]);//  &#125;  char *message = (char*)payload;  if (length &gt; 3) &#123;    length = 3;  &#125;;  char dest[length] = &quot;&quot;;  strncpy(dest, message, length);  Serial.println(dest);  if (strcmp(topic, topic3) == 0)&#123;    setfan = atoi(dest);    ac.setFan(setfan);    printState();  &#125; else if (strcmp(topic, topic2) == 0) &#123;    settemp = atoi(dest);    ac.setTemp(settemp);    printState();  &#125; else if (strcmp(topic, topic1) == 0) &#123;    if (strcmp(dest, &quot;hea&quot;)==0)&#123;      ac.setMode(kKelvinatorHeat);    &#125; else if (strcmp(dest, &quot;coo&quot;)==0) &#123;      ac.setMode(kKelvinatorCool);    &#125; else if (strcmp(dest, &quot;dry&quot;)==0) &#123;      ac.setMode(kKelvinatorDry);    &#125; else if (strcmp(dest, &quot;aut&quot;)==0) &#123;      ac.setMode(kKelvinatorAuto);    &#125;    printState();  &#125; else if (strcmp(topic, topic0) == 0)&#123;    int flag = 0;    if (strcmp(dest, &quot;on&quot;) == 0) &#123;      ac.on();      flag = 1;    &#125; else if (strcmp(dest, &quot;off&quot;) == 0)&#123;      ac.off();      flag = 1;    &#125;    if (flag == 1) &#123;      printState();      ac.send();      delay(500);      ac.send();      delay(500);      ac.send();      delay(500);      ac.send();      delay(500);      ac.send();      ac.off();    &#125;;  &#125; else if (strcmp(topic, topic4) == 0)&#123;    if (strcmp(dest, &quot;on&quot;) == 0)&#123;      ac.setSwingVertical(true);    &#125; else if (strcmp(dest, &quot;off&quot;) == 0)&#123;      ac.setSwingVertical(false);    &#125;;  &#125; else if (strcmp(topic, topic5) == 0)&#123;    if (strcmp(dest, &quot;on&quot;) == 0)&#123;      ac.setSwingHorizontal(true);    &#125; else if (strcmp(dest, &quot;off&quot;) == 0)&#123;      ac.setSwingHorizontal(false);    &#125;;  &#125;;&#125;void reconnect() &#123;  while (!client.connected()) &#123;    Serial.print(&quot;Attempting MQTT connection...&quot;);    // Attempt to connect    if (client.connect(client_id, mqtt_username, mqtt_password)) &#123;      Serial.println(&quot;connected&quot;);      // 连接成功时订阅主题      client.subscribe(topic0);      client.subscribe(topic1);      client.subscribe(topic2);      client.subscribe(topic3);      client.subscribe(topic4);      client.subscribe(topic5);    &#125; else &#123;      Serial.print(&quot;failed, rc=&quot;);      Serial.print(client.state());      Serial.println(&quot; try again in 5 seconds&quot;);      // Wait 5 seconds before retrying      delay(5000);    &#125;  &#125;&#125;void printState() &#123;  // Display the settings.  Serial.println(&quot;Kelvinator A/C remote is in the following state:&quot;);  Serial.printf(&quot;  %s\\n&quot;, ac.toString().c_str());  // Display the encoded IR sequence.  unsigned char* ir_code = ac.getRaw();  Serial.print(&quot;IR Code: 0x&quot;);  for (uint8_t i = 0; i &lt; kKelvinatorStateLength; i++)    Serial.printf(&quot;%02X&quot;, ir_code[i]);  Serial.println();&#125;void loop() &#123;  if (!client.connected()) &#123;    reconnect();  &#125;  client.loop();&#125;","categories":["极客","服务器"],"tags":["homeassistant","智能家居"]},{"title":"自然语言处理","url":"/2021/12/nlp_python/","content":"基础知识\n特高频特低频词都不能用于分析语言风格\n\n高频长词，连词搭配可以分析风格\n\n语言理解技术：词义消歧，指代消歧\n\n语言理解应用：机器翻译（MT），含义识别（RTE）\n\nnltk.Text():\n\n\n\n方法\n作用\n\n\n\nText(words)\n对象构造\n\n\nconcordance(word, width=79, lines=25)\n显示word出现的上下文\n\n\ncommon_contexts(words)\n显示words出现的相同模式\n\n\nsimilar(word)\n显示word的相似词\n\n\ncollocations(num=20, window_size=2)\n显示最常见的二词搭配\n\n\ncount(word)\nword出现的词数\n\n\ndispersion_plot(words)\n绘制words中文档中出现的位置图\n\n\nvocab()\n返回文章去重的词典\n\n\n\nGB2312，Latin-2，UTF-8是对应Unicode的一部分\n\n正则匹配：^ 匹配开始，$ 匹配结尾，? 前方可选，. 匹配任意1个，+ 前方一个或多个，* 前方零个或多个，{m,n} 至少重复m次不多于n次  \n\n\n\n操作符\n行为\n\n\n\n[abc]\n匹配字符集合\n\n\ned|ing\n匹配指定的字符串（析取）\n\n\na(b|c)+\n括号表示操作符的范围\n\n\n\n辅音元音序列，从中可以看出s和t后元音的分布几乎是互补的：  \n\n\n\n\na\ne\ni\no\nu\n\n\n\ns\n0\n0\n100\n2\n1\n\n\nt\n47\n8\n0\n148\n37\n\n\n\n词干提取：lying -&gt; lie （会产生非词）；词形归并：women -&gt; woman；非标准词：数字、缩写、日期\n\n正则简写：[a-zA-Z0-9_] = \\w、[ \\t\\n] = \\s\n\n\n词性标注\n词性标记集：adj，adv，cnj连词，det限定词 ……\n使用out of vocabulary (UNK)替换超出词汇\n简单词性标注：默认标注 &lt;- 正则标注 &lt;- 查询标注\n一个语料库出现的新词大多数是名词，且一个语料库中最多的往往也是名词，所以一般将名词作为默认值\n频率标注：1-gram unigram、2-gram bigram、3-gram trigram，n-gram标注器中n大于3时，面临数据稀疏问题\n为了防止多词查询跨句，在句子开始处加None\n标注策略失败要回退上级策略，直至默认标注\n给定当前单词及其前两个标记，在约5%的情况中，有一个以上的标记分配给当前词\n修正标注（Brill）：基于规则不断修正\n语言学家使用形态学、句法和语义线索确定一个词的类别\n\n文本分类\n训练数据分为：train、dev-test、test三部分\n最大熵马尔可夫模型和线性链条件随机场模型\n任务：姓名性别识别，对话行为分类，句子分割，文本蕴含判断\n精确度= true &amp; positive / positive，召回率 = true &amp; positive / true\n交叉验证：将原始语料分为N个子集（folds）。对于每一个折叠，我们使用除这个折叠中的数据外所有数据来训练模型，然后在这个折叠上测试模型\n决策树：\n信息增益：得到某个信息后熵的减少\n底层节点样本太少：设置停止阈值 or 对低性能节点进行裁剪\n特征按照顺序处理，难以处理相互独立多特征的情况\n\n\n朴素贝叶斯：\n假设：特征相互独立\n零计数和平滑：对于未出现、低频率的分类进行平滑，提升重要性\n\n\n最大熵分类：\n假设：满足所有约束条件，分布越平均熵越大越好\n\n\n\n信息提取\n名词短语分块（NP-chunking）：\n可选的跟着任意数目形容词（JJ）的限定词（DT）和名词（NN）组成\nIOB标记：I（inside），O（outside）或Ｂ（begin）\n\n\n\n\n\nVP分块，如has already delivered；PP分块，如because of\n命名实体识别：组织，人，地点，日期，货币，设施，地缘政治实体\n有了明确的命名实体就可以进行关系抽取\n\n句子结构\n歧义句子：While hunting in Africa, I shot an elephant in my pajamas. How an elephant got into my pajamas I’ll never know.\n\n\n\nand不能连接NP和AP，e.g., It is the worst part and clumsy looking.\n解析器：下降递归分析、移进-归约分析、左角落分析（带自下而上过滤的自上而下的方法）、图表分析（动态规划）\n左角落分析：\n\n\n\n图表分析（动态规划）：    &gt;&gt; tokens = &quot;I shot an elephant in my pajamas&quot;.split()&gt;&gt; wfst0 = init_wfst(tokens, groucho_grammar)&gt;&gt; wfst1 = complete_wfst(wfst0, tokens, groucho_grammar)&gt;&gt; display(wfst1, tokens)WFST  1   2     3　   4　   5　   6　   70　  NP   .　   .　   S　   .　   .　   S1　   .   V　   .　  VP　   .　   .　  VP2　   .   .   Det　  NP　   .　   .　   .3　   .   .　   .　   N　   .　   .　   .4　   .   .　   .　   .　   P　   .　  PP5　   .   .　   .　   .　   .　 Det　  NP6　   .   .　   .　   .　   .　   .　   N\n依存关系的表示：(shot I (elephant an (in (pajamas my))))、(shot I (elephant an) (in (pajamas my)))  \n动词及物or不及物称为动词的配价  \n随着句子的增长，歧义是爆炸式增长的。因此需要加权文法，即为每一个分叉分配概率，且加和为1  \n\n","categories":["人工智能","NLP"],"tags":["NLP"]},{"title":"Openwrt搭建","url":"/2021/08/openwrt_init/","content":"心心念念了好久，暑假回家终于用屯的二手树莓派搭建起了Openwrt的软路由。\n镜像安装因为使用的是树莓派4b，网上有现成的为树莓派4b编译的镜像OpenWrt-Rpi，而且每天基于Github Action自动更新。然后将下好的镜像使用balenaEtcher烧录到SD卡内插入到树莓派中。有意思的是，重新烧录同样的镜像，树莓派是不会重新加载的，所以每次我重写镜像都需要换个镜像刷写，再刷回来以进行重置。\n\nOpenWrt-Rpi\nbalenaEtcher\n\n网络设置因为是用树莓派做旁路由，所以需要对于网络进行一定的设置。主要是在主路由上设置网关和DNS服务器地址指向旁路由。在树莓派上修改ip地址到主路由的网段，并将网关改为主路由的ip地址。具体到我，我设定树莓派向外提供服务，譬如将默认DNS服务器指向旁路由，由旁路由运行Adguard Home提供DNS服务，进行广告过滤。但是并没有设置主路由网关指向旁路由，也就没有默认所有流量经过旁路由。\n\nAdguard Home\n\n网络拓扑刷机成功后，连上树莓派的默认Wifi。首先要将旁路由的ip地址改到主路由网段：\nuci set network.lan.ipaddr=192.168.2.110uci commit network/etc/init.d/network restart\n然后就可以将树莓派插到主路由的LAN口上了，并通过刚刚设置的ip，对于我就是192.168.2.110，直接访问了。整个网络拓扑如下\n\nDNS服务配置由于我主路由本来运行着SmartDNS，我关闭了主路由的DNS服务，从主路由将DNS服务器直接设置为树莓派的ip。\n\nSmartDNS\n\n\n这里遇到的一个坑是，本来计划直接让Adguard Home接管53端口，但是出现了梯子用不了等网络的问题。最后还是选用将Adguard Home作为dnsmasq的上游服务器，可能这样其他服务也可以正常设置DNS服务，如修改dnsmasq配置。\n因为我家光猫不支持ipv6，所以我在旁路由DHCP/DNS和Adguard Home中分别禁止了ipv6解析，以便快速返回解析结果。\n自定义域名Adguard Home不仅仅可以用于拦截广告。可以通过Adguard Home自定义拦截规则，来设置自定义域名，譬如设置mywifi.org指向192.168.2.110，条目如下：\n192.168.2.110 mywifi.org\n这里有一点，Openwrt会拦截指向内网的解析，需要关掉网络 $\\to$ DHCP/DNS $\\to$ 基本设置的重定向保护，解析才能生效。\n内网穿透因为有公网服务器，所以想把家里的局域网和公网服务器组网进行内网穿透。我使用的是zerotier这款开源软件。这款软件一定条件下可以实现点对点通信，突破公网服务器做内网穿透的带宽限制。因为zerotier的节点服务器都在国外，我在公网服务器上搭建了中转通信的moon服务器，加速访问。我还发现了一款好的zerotier第三方安卓客户端ZerotierFix，可以在安卓端方便地添加moon节点。\n\nzerotier\nzerotier moon\nZerotierFix\n\n具体的整个zerotier的配置流程，强烈推荐b站up主“韩风Talk”的讲解视频\n\n    \n","categories":["极客","服务器"],"tags":["Openwrt","路由器"]},{"title":"凸优化1-3","url":"/2022/04/convex_optim1/","content":"\nBoyd斯坦福公开课视频：https://www.bilibili.com/video/BV1Pg4y187Ed课件：https://stanford.edu/class/ee364a/lectures.html\n\n简介\n最小二乘，线性规划可以划归为凸优化\n\n例子：m盏灯照射在n段上，每段强度 , $a_{kj}=r^{-2}{kj}\\max { \\cos \\theta{kj}, 0 }$\n\n优化目标：达到尽量均匀光照强度，即限制条件：功率\n方法：\n\n\n\n\n\n s.t. \n\n s.t. , \n\n\n\n额外限制：\n\n任意十盏灯不超过总功率一半，convex\n不超过一半的灯亮，concave\n\n\n局部最优：需要好的初始化，没有全局最优的信息\n全局最优：最差算法复杂度随问题大小指数增加，一般需要转化为凸优化问题\n\n\n凸集\nconvex hull: 凸包\n\nconvex cone: , s.t. \n\nnorm cone: \n\nPositive semidefinite cone  is a convex cone, 这里  对称矩阵集，\n, \n\n\nellipsoid (椭球):  是对称正定的 or \n\n保凸性操作：\n\n相交：, \n\n仿射：,  is convex, then  and  is convex, too. \n例子：i. , ii. , \n\n投射：, …\n\nlinear-fractional: , , …\n\n\n\na closed, solid (nonempty interior), pointed (contains no line) convex cone  is a proper cone.\n\n广义不等式：, \n例子：i. ,  ii. , 是半正定的\nminimum: , minimal: , 判断方法：❓\n\nps. 广义不等式一般仅为偏序关系\n\nSeparating hyperplane theorem:\nif C and D are disjoint convex sets, then there exists  and  s.t.  and . If C is closed and D is a singleton, then the inequation is strict.\n\nSupporting hyperplane theorem:\nIf C is convex, the there exists a supporting hyperplane at every boundary point of C.\n\ndual cone: \n例子：i.  ii. ,  iii.  ,   \n\n\n凸函数\n is concave if  is convex\n例子：i.  ii. $f(X)=|X|2=$$=(\\lambda{max}(X^TX))^{1/2}$ ❓\n\n is convex   is convex\n例子：，则有\n\n这里，是的特征值\n\n, \n例子：i. ,  ii. ,  \niii.  is convex, ,  ❓\n\nepigraph of : ,  is convex   is a convex set ❓\n\nJensen’s inequality: \n\n保凸性操作：\n\n, , \n\n, \n\nsum, max\n\nsup: \n\n  is convex if  convex  convex  nodecrease\nor  concave  convex  noincrease\n例子： if  convex,  if  is concave and positive\n\n, , …\n例子： is convex if  are convex  \n\n\n\n\n","categories":["数学","凸优化"],"tags":["凸优化"]}]